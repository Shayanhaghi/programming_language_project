; Session 10
; Make an interpreter using Racket

#lang racket


(struct const (int) #:transparent) ; int should hold a number
(struct negate (e1) #:transparent)  ; e1 should hold an expression
(struct add (e1 e2) #:transparent) ; e1, e2 should hold expressions
(struct bool (b) #:transparent) ; b should hold #t or #f
(struct if-then-else (e1 e2 e3) #:transparent) ; e1, e2, e3 should hold expressions
; a value in this language is a legal const or bool

(define test1 (add (negate (add (const 2) 
                                     (const 2))) 
                        (const 7)))

(define test2 (add (negate (add (const 2)
                                     (const 2))) 
                        (if-then-else (bool #f) 
                                      (const 7) 
                                      (bool #t))))

(define non-test (add (negate (add (const #t) 
                                        (const 2))) 
                           (const 7)))

(define (eval-exp-wrong e)
  (cond [(const? e) ; value evaluates to itself
         e] 
        [(negate? e) 
         (const (- (const-int (eval-exp-wrong (negate-e1 e)))))] ; Why are we sure about that the return value of eval-exp-wrong will be const?!
        [(add? e) 
         (let ([i1 (const-int (eval-exp-wrong (add-e1 e)))]
               [i2 (const-int (eval-exp-wrong (add-e2 e)))])
           (const (+ i1 i2)))]

        [(bool? e) 
         e]
        [(if-then-else? e)
         (if (bool-b (eval-exp-wrong (if-then-else-e1 e))) ; wrongly assumed
             (eval-exp-wrong (if-then-else-e2 e))
             (eval-exp-wrong (if-then-else-e3 e)))]
        ;; Error handling - Type ONE ;;
        [#t (error "eval-exp expected an exp")] ; not strictly necessary but helps debugging
        ))




(define (eval-exp-better e)
  (cond [(const? e) ; e can be other types than integer! 
         e] 
        [(negate? e)
         ;; Error handling - Type TWO ;;
         (let ([v (eval-exp-better (negate-e1 e))])
           (if (const? v)
               (const (- (const-int v)))
               (error "negate applied to non-number")))]
        [(add? e) 
         (let ([v1 (eval-exp-better (add-e1 e))]
               [v2 (eval-exp-better (add-e2 e))])
           (if (and (const? v1) (const? v2))
               (const (+ (const-int v1) (const-int v2)))
               (error "add applied to non-number")))]
        [(bool? e) 
         e]
        [(if-then-else? e) 
         (let ([v-test (eval-exp-better (if-then-else-e1 e))])
           (if (bool? v-test)
               (if (bool-b v-test)
                   (eval-exp-better (if-then-else-e2 e))
                   (eval-exp-better (if-then-else-e3 e)))
               (error "if-then-else applied to non-boolean")))]
        [#t (error "eval-exp-better expected an exp")] ; not strictly necessary but helps debugging
        ))




(define (eval-exp e)
  (cond [(const? e)
         ;; Error handling - Type THREE ;;
         (let ([v (const-int e)])
           (if (integer? v)
               e
               (error "const should be an integer")))
         ] 
        [(negate? e) 
         (let ([v (eval-exp (negate-e1 e))])
           (if (const? v)
               (const (- (const-int v)))
               (error "negate applied to non-number")))]
        [(add? e) 
         (let ([v1 (eval-exp (add-e1 e))]
               [v2 (eval-exp (add-e2 e))])
           (if (and (const? v1) (const? v2))
               (const (+ (const-int v1) (const-int v2)))
               (error "add applied to non-number")))]

        [(bool? e) 
         (let ([v (bool-b e)])
           (if (boolean? v)
               e
               (error "bool should be #t or #f")))]
        [(if-then-else? e) 
         (let ([v-test (eval-exp (if-then-else-e1 e))])
           (if (bool? v-test)
               (if (bool-b v-test)
                   (eval-exp (if-then-else-e2 e))
                   (eval-exp (if-then-else-e3 e)))
               (error "if-then-else applied to non-boolean")))]
        [#t (eval(error "eval-exp expected an exp"))] ; not strictly necessary but helps debugging
        ))


;; Note: You have to handle all three types in your project
;; However, you cannot do anything for this example --> (eval-exp (div 2 3)) [Assume that the parser has already verified these syntactic issues]





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro (Extending our language syntax)
(define (andalso e1 e2)
  (if-then-else e1 e2 (bool #f)))

(define (double e)
  (add e (const 2)))

;; You can even define like this, but don't do that!
(define (power e)
  (add (const e) (const e)))


(define (list-product es)
  (if (null? es)
      (const 1)
      (add (car es) (list-product (cdr es)))))

(define testMacro (andalso (eq-num (double (const 4))
                                (list-product (list (const 2)
                                                    (const 2)
                                                    (const 3)
                                                    (const 3)
                                                    )
                                              )
                                )
                        (bool #t)))
						
						

						
;;  https://www.youtube.com/watch?v=rbNVmUncxXg
;;  https://www.youtube.com/watch?v=uHvNfSEkmdY
;;  https://www.youtube.com/watch?v=OGGV1nVh_N0
;;  https://www.youtube.com/watch?v=RpRQehzxa-I